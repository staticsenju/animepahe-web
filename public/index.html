<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Animepahe Web</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="referrer" content="no-referrer" />
<style>
:root {
  color-scheme: dark light;
  --bg:#0e0f13;
  --surface:#16181e;
  --surface-alt:#1e2128;
  --border:#262a31;
  --fg:#e8eaf0;
  --fg-dim:#a3a8b3;
  --accent:#6366f1;
  --accent-hover:#4f46e5;
  --error:#ef4444;
  --warn:#f59e0b;
  --episodes-bar-height:120px;
  --player-max-width:1680px;
}
* { box-sizing:border-box; }
html,body {
  margin:0;
  height:100%;
  background:var(--bg);
  color:var(--fg);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;
}
body {
  display:flex;
  flex-direction:column;
  overflow:hidden;
}

/* Header (always visible) */
header {
  display:flex;
  gap:.75rem;
  align-items:center;
  padding:.85rem 1.2rem;
  background:linear-gradient(90deg,#14161c,#191c23 50%,#14161c);
  border-bottom:1px solid var(--border);
  z-index:50;
  position:relative;
}
header h1 {
  margin:0;
  font-size:1.05rem;
  letter-spacing:.5px;
  font-weight:600;
  background:linear-gradient(95deg,#fff,#aab2ff);
  -webkit-background-clip:text;
  color:transparent;
}
header input {
  flex:1 1 auto;
  min-width:240px;
  background:#20232b;
  border:1px solid var(--border);
  color:var(--fg);
  padding:.65rem .8rem;
  border-radius:10px;
  font-size:.9rem;
  outline:none;
}
header input:focus {
  border-color:var(--accent);
  box-shadow:0 0 0 1px var(--accent) inset;
}
button {
  background:var(--accent);
  color:#fff;
  border:none;
  font-weight:600;
  letter-spacing:.4px;
  font-size:.85rem;
  padding:.65rem 1.05rem;
  border-radius:9px;
  cursor:pointer;
  transition:background .15s,opacity .15s;
  display:inline-flex;
  align-items:center;
  gap:.4rem;
}
button:hover { background:var(--accent-hover); }
button:disabled { opacity:.55; cursor:not-allowed; }

#status {
  font-size:.7rem;
  letter-spacing:.4px;
  opacity:.7;
  white-space:nowrap;
}

/* Fullscreen selection area */
#selectScreen {
  position:relative;
  flex:1;
  display:flex;
  flex-direction:column;
  padding:1.2rem 1.4rem 2rem;
  overflow:hidden;
  gap:1rem;
  transition:opacity .25s;
}

#resultsGrid {
  flex:1 1 auto;
  width:100%;
  display:grid;
  gap:1rem;
  grid-template-columns:repeat(auto-fill,minmax(150px,1fr));
  overflow:auto;
  padding:.2rem;
  scrollbar-width:thin;
}
.card {
  position:relative;
  background:var(--surface);
  border:1px solid var(--border);
  border-radius:14px;
  display:flex;
  flex-direction:column;
  padding:0;
  cursor:pointer;
  overflow:hidden;
  transition:transform .18s, border-color .25s, box-shadow .25s;
  min-height:240px;
  isolation:isolate;
}
.card:before {
  content:"";
  position:absolute;
  inset:0;
  background:linear-gradient(to top,rgba(0,0,0,.65) 5%,rgba(0,0,0,.05) 70%);
  pointer-events:none;
  opacity:.9;
  mix-blend-mode:normal;
}
.card:hover {
  transform:translateY(-4px);
  border-color:#3b4050;
  box-shadow:0 6px 18px -6px rgba(0,0,0,.5),0 0 0 1px rgba(255,255,255,.04) inset;
}
.card img {
  width:100%;
  height:100%;
  object-fit:cover;
  position:absolute;
  inset:0;
  filter:saturate(1.1);
  transition:filter .3s;
}
.card:hover img { filter:saturate(1.25) brightness(1.05); }
.card .info {
  position:relative;
  margin-top:auto;
  padding:.55rem .65rem .65rem;
  z-index:2;
  display:flex;
  flex-direction:column;
  gap:.3rem;
}
.card .title {
  font-size:.75rem;
  line-height:1.15;
  font-weight:600;
  letter-spacing:.4px;
  max-height:2.3em;
  overflow:hidden;
}
.card .meta {
  font-size:.55rem;
  opacity:.65;
  letter-spacing:.5px;
  display:flex;
  gap:.35rem;
  flex-wrap:wrap;
}

.empty-hint {
  font-size:.75rem;
  opacity:.5;
  letter-spacing:.4px;
  padding:.75rem;
}

/* Player view container (hidden until select) */
#playerScreen {
  position:relative;
  flex:1;
  display:none;
  flex-direction:column;
  align-items:center;
  overflow:hidden;
  padding:0;
}

/* Appear when active */
body.mode-player #selectScreen { display:none; }
body.mode-player #playerScreen { display:flex; }

/* Player wrapper sizing */
.player-shell {
  position:relative;
  width:100%;
  max-width:var(--player-max-width);
  margin:0 auto;
  display:flex;
  flex-direction:column;
  padding:0 1.2rem;
  box-sizing:border-box;
  height:calc(100% - var(--episodes-bar-height) - 10px);
}

.player-top-bar {
  display:flex;
  gap:.65rem;
  padding:.9rem 0 .55rem;
  align-items:center;
  flex-wrap:wrap;
  z-index:10;
}

.player-title {
  font-size:.95rem;
  font-weight:600;
  letter-spacing:.5px;
  display:flex;
  align-items:center;
  gap:.6rem;
}

select {
  background:#20232b;
  border:1px solid var(--border);
  color:var(--fg);
  font-size:.7rem;
  padding:.5rem .55rem;
  border-radius:8px;
  letter-spacing:.4px;
  min-width:110px;
  outline:none;
}
select:focus {
  border-color:var(--accent);
  box-shadow:0 0 0 1px var(--accent) inset;
}

.player-wrapper {
  flex:1 1 auto;
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#000;
  border-radius:16px;
  overflow:hidden;
  border:1px solid #1f2229;
  box-shadow:0 3px 18px -6px rgba(0,0,0,.6),0 0 0 1px rgba(255,255,255,.03) inset;
}
video {
  width:100%;
  height:100%;
  background:#000;
  outline:none;
}

.player-status {
  font-size:.65rem;
  letter-spacing:.4px;
  opacity:.7;
  padding:.35rem 0 .2rem;
  min-height:1em;
}

.mirror-panel-toggle {
  background:#2b2f37;
  font-size:.65rem;
  padding:.45rem .7rem;
}
.mirror-panel-toggle:hover { background:#353a44; }

#mirrorPanel {
  display:none;
  position:absolute;
  top:4.3rem;
  right:1.2rem;
  width:260px;
  max-height:360px;
  background:var(--surface-alt);
  border:1px solid var(--border);
  border-radius:14px;
  padding:.75rem .75rem .9rem;
  box-shadow:0 10px 30px -10px rgba(0,0,0,.7);
  display:flex;
  flex-direction:column;
  gap:.65rem;
  z-index:30;
}
#mirrorPanel.active { display:flex; }
.mirror-list {
  display:flex;
  flex-direction:column;
  gap:.55rem;
  overflow:auto;
  scrollbar-width:thin;
}
.mirror {
  background:#242830;
  border:1px solid #2f343d;
  padding:.55rem .6rem;
  border-radius:10px;
  font-size:.6rem;
  display:flex;
  flex-direction:column;
  gap:.35rem;
}
.mirror-header {
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:.5rem;
  font-weight:600;
  letter-spacing:.5px;
  font-size:.6rem;
}
.mirror button {
  font-size:.55rem;
  padding:.35rem .55rem;
  border-radius:7px;
  font-weight:600;
  background:#3a4150;
}
.mirror button:hover { background:#4a5262; }

.badge {
  background:#303642;
  padding:2px 6px;
  border-radius:6px;
  font-size:.55rem;
  letter-spacing:.5px;
  font-weight:500;
}

#episodesBar {
  position:relative;
  width:100%;
  max-width:var(--player-max-width);
  margin:0 auto;
  height:var(--episodes-bar-height);
  display:flex;
  flex-direction:column;
  padding:.5rem 1.2rem 1rem;
  box-sizing:border-box;
  gap:.5rem;
}
.episodes-scroll {
  flex:1;
  display:flex;
  gap:.5rem;
  overflow-x:auto;
  overflow-y:hidden;
  scrollbar-width:thin;
  padding:.2rem .1rem;
}
.ep-chip {
  flex:0 0 auto;
  background:#1e2229;
  border:1px solid #2c313a;
  min-width:58px;
  padding:.45rem .5rem .5rem;
  border-radius:10px;
  font-size:.55rem;
  display:flex;
  flex-direction:column;
  gap:.3rem;
  cursor:pointer;
  transition:background .18s, border-color .18s, transform .18s;
  align-items:flex-start;
}
.ep-chip:hover {
  background:#272d36;
  border-color:#3a414d;
  transform:translateY(-2px);
}
.ep-chip.active {
  background:linear-gradient(150deg,#3d49ff,#6366f1);
  border-color:#6366f1;
  color:#fff;
  box-shadow:0 4px 14px -4px rgba(70,80,255,.6);
}
.ep-num { font-weight:600; letter-spacing:.6px; }
.ep-meta { opacity:.7; letter-spacing:.5px; }

.subtitle-select-inline {
  margin-left:auto;
  display:flex;
  gap:.5rem;
  align-items:center;
}

footer {
  display:none;
}

.error { color:var(--error); }
.warn { color:var(--warn); }

@media (max-width:900px) {
  .player-top-bar { flex-direction:column; align-items:flex-start; }
  .subtitle-select-inline { margin-left:0; }
  #mirrorPanel { right:.9rem; width:220px; }
  .player-shell { padding:0 .9rem; }
  #episodesBar { padding:.5rem .9rem 1rem; }
}
</style>
</head>
<body class="mode-select">
<header>
  <h1>Animepahe</h1>
  <input id="searchInput" type="text" placeholder="Search anime..." autocomplete="off" />
  <button id="searchBtn">Search</button>
  <span id="status"></span>
</header>

<!-- Fullscreen Selection Screen -->
<section id="selectScreen">
  <div id="resultsGrid"></div>
  <div id="emptyHint" class="empty-hint">Search for a title to begin.</div>
</section>

<!-- Player Screen (hidden initially) -->
<section id="playerScreen">
  <div class="player-shell">
    <div class="player-top-bar">
      <div class="player-title">
        <span id="seriesTitle"></span>
        <span id="currentEpLabel" style="font-size:.7rem;opacity:.7;"></span>
      </div>

      <select id="resolutionSelect">
        <option value="">Resolution (Auto)</option>
      </select>

      <select id="audioSelect">
        <option value="">Audio (Auto)</option>
      </select>

      <select id="subtitleSelect">
        <option value="">Subtitles (None)</option>
      </select>

      <button id="applyBtn" disabled>Apply</button>
      <button id="refreshMirrorsBtn" disabled>Mirrors</button>
      <button id="reloadPlaylistBtn" disabled>Reload</button>
      <button id="backBtn" style="background:#394150;">Back</button>
      <button id="toggleAutoplayBtn" style="background:#394150;">Autoplay: Off</button>

      <div class="subtitle-select-inline">
        <span id="playerStatus" class="player-status"></span>
      </div>
    </div>

    <div class="player-wrapper">
      <video id="video" controls playsinline preload="metadata"></video>
    </div>
  </div>

  <div id="episodesBar">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div style="font-size:.65rem;letter-spacing:.5px;font-weight:600;opacity:.75;">EPISODES</div>
    </div>
    <div id="episodesRow" class="episodes-scroll"></div>
  </div>

  <!-- Mirror Panel -->
  <div id="mirrorPanel">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div style="font-size:.7rem;font-weight:600;letter-spacing:.5px;">Mirrors</div>
      <button id="closeMirrorPanel" style="background:#404652;font-size:.55rem;padding:.3rem .55rem;">Close</button>
    </div>
    <div id="mirrorList" class="mirror-list"></div>
  </div>
</section>

<script src="https://cdn.jsdelivr.net/npm/hls.js@1/dist/hls.min.js"></script>
<script>
/* ========= STATE ========= */
let searchResults = [];
let selectedAnime = null;
let episodes = [];
let currentEpisode = null;
let lastPlaylistUrl = '';
let lastCookie = '';
let appliedResolution = '';
let appliedAudio = '';
let subtitleTracks = [];
let activeSubtitleUri = '';
let autoplay = false;
let hlsInstance = null;
let mirrorButtons = [];

/* ========= DOM ========= */
const $ = id => document.getElementById(id);
const els = {
  status: $('status'),
  searchInput: $('searchInput'),
  searchBtn: $('searchBtn'),
  resultsGrid: $('resultsGrid'),
  emptyHint: $('emptyHint'),
  playerScreen: $('playerScreen'),
  resolutionSelect: $('resolutionSelect'),
  audioSelect: $('audioSelect'),
  subtitleSelect: $('subtitleSelect'),
  applyBtn: $('applyBtn'),
  refreshMirrorsBtn: $('refreshMirrorsBtn'),
  reloadPlaylistBtn: $('reloadPlaylistBtn'),
  playerStatus: $('playerStatus'),
  seriesTitle: $('seriesTitle'),
  currentEpLabel: $('currentEpLabel'),
  video: $('video'),
  episodesRow: $('episodesRow'),
  backBtn: $('backBtn'),
  toggleAutoplayBtn: $('toggleAutoplayBtn'),
  mirrorPanel: $('mirrorPanel'),
  mirrorList: $('mirrorList'),
  closeMirrorPanel: $('closeMirrorPanel'),
  refreshMirrorsBtn: $('refreshMirrorsBtn')
};

/* ========= UTIL ========= */
function setStatus(msg, kind='') {
  els.status.textContent = msg;
  els.status.style.color = kind==='error' ? 'var(--error)'
    : kind==='warn' ? 'var(--warn)' : 'var(--fg-dim)';
}
function setPlayerStatus(msg, kind='') {
  els.playerStatus.textContent = msg;
  els.playerStatus.style.color = kind==='error' ? 'var(--error)'
    : kind==='warn' ? 'var(--warn)' : 'var(--fg-dim)';
}
function spinner(){ return '…'; }
function pickPoster(item){
  return item.poster || item.image || item.cover || item.snapshot || '';
}

/* ========= SEARCH ========= */
async function doSearch() {
  const q = els.searchInput.value.trim();
  if (!q) { setStatus('Enter a search term'); return; }
  setStatus('Searching ' + spinner());
  try {
    const res = await fetch('/api/search?q=' + encodeURIComponent(q));
    if (!res.ok) throw new Error(res.status + ' search error');
    const data = await res.json();
    searchResults = data?.data || data?.results || [];
    renderResults();
    if (!searchResults.length) setStatus('No results');
    else setStatus(searchResults.length + ' result(s)');
  } catch(e) {
    setStatus('Search error: ' + e.message, 'error');
  }
}

function renderResults() {
  els.resultsGrid.innerHTML = '';
  if (!searchResults.length) {
    els.emptyHint.style.display = 'block';
    return;
  }
  els.emptyHint.style.display = 'none';
  searchResults.forEach(item => {
    const card = document.createElement('div');
    card.className = 'card';
    const imgUrl = pickPoster(item);
    if (imgUrl) {
      const img = document.createElement('img');
      img.loading = 'lazy';
      img.src = imgUrl;
      card.appendChild(img);
    }
    const info = document.createElement('div');
    info.className = 'info';
    const titleDiv = document.createElement('div');
    titleDiv.className = 'title';
    titleDiv.textContent = item.title || 'Untitled';
    const meta = document.createElement('div');
    meta.className = 'meta';
    const pieces = [];
    if (item.type) pieces.push(item.type);
    if (item.year) pieces.push(item.year);
    if (item.episode) pieces.push('Ep ' + item.episode);
    meta.textContent = pieces.join(' • ');
    info.appendChild(titleDiv);
    info.appendChild(meta);
    card.appendChild(info);
    card.addEventListener('click', () => selectAnime(item));
    els.resultsGrid.appendChild(card);
  });
}

/* ========= SELECT / EPISODES ========= */
async function selectAnime(item) {
  selectedAnime = item;
  episodes = [];
  currentEpisode = null;
  document.body.classList.add('mode-player');
  els.seriesTitle.textContent = item.title || 'Untitled';
  els.currentEpLabel.textContent = '';
  clearPlayerState();
  setPlayerStatus('Loading episodes ' + spinner());

  try {
    let token = item.session || item.id || item.slug;
    if (!token) throw new Error('Missing session/id');
    const r = await fetch('/api/episodes?id=' + encodeURIComponent(token));
    if (!r.ok) throw new Error(r.status + ' episodes error');
    const data = await r.json();
    episodes = data?.episodes || data?.data || [];
    renderEpisodesBar();
    setPlayerStatus('Episodes loaded');
    if (episodes.length) loadEpisode(episodes[0]);
  } catch (e) {
    setPlayerStatus('Episodes error: ' + e.message,'error');
  }
}

function renderEpisodesBar() {
  els.episodesRow.innerHTML = '';
  episodes.forEach(ep => {
    const chip = document.createElement('div');
    chip.className = 'ep-chip';
    chip.innerHTML = `
      <div class="ep-num">#${ep.episode ?? '?'}</div>
      <div class="ep-meta">${(ep.audio || '')} ${(ep.duration||'').replace(/^00:/,'') }</div>
    `.trim();
    chip.addEventListener('click', () => loadEpisode(ep));
    els.episodesRow.appendChild(chip);
  });
  highlightCurrentEpisode();
}

function highlightCurrentEpisode() {
  const chips = els.episodesRow.querySelectorAll('.ep-chip');
  chips.forEach(ch => ch.classList.remove('active'));
  if (!currentEpisode) return;
  const idx = episodes.findIndex(e => e.session === currentEpisode.session);
  if (idx >= 0 && chips[idx]) chips[idx].classList.add('active');
}

/* ========= PLAYER CORE ========= */
function clearPlayerState() {
  els.resolutionSelect.innerHTML = '<option value="">Resolution (Auto)</option>';
  els.audioSelect.innerHTML = '<option value="">Audio (Auto)</option>';
  els.subtitleSelect.innerHTML = '<option value="">Subtitles (None)</option>';
  subtitleTracks = [];
  activeSubtitleUri = '';
  appliedResolution = '';
  appliedAudio = '';
  lastPlaylistUrl = '';
  lastCookie = '';
  mirrorButtons = [];
  els.applyBtn.disabled = true;
  els.refreshMirrorsBtn.disabled = true;
  els.reloadPlaylistBtn.disabled = true;
  if (hlsInstance) { hlsInstance.destroy(); hlsInstance = null; }
  els.video.removeAttribute('src');
  els.video.load();
}

async function loadEpisode(ep) {
  currentEpisode = ep;
  highlightCurrentEpisode();
  els.currentEpLabel.textContent = 'EP ' + (ep.episode ?? '?');
  clearPlayerState();
  setPlayerStatus('Fetching mirrors ' + spinner());
  try {
    const slug = (selectedAnime?.slug || selectedAnime?.session || selectedAnime?.id || '').trim();
    if (!slug) throw new Error('Missing slug');
    const url = `/api/play/${encodeURIComponent(slug)}/${encodeURIComponent(ep.session)}?listOnly=true`;
    const r = await fetch(url);
    const data = await r.json();
    if (!r.ok) throw new Error(data.error || 'Mirror fetch failed');
    mirrorButtons = data.buttons || [];
    populateSelectors(mirrorButtons);
    els.applyBtn.disabled = false;
    els.refreshMirrorsBtn.disabled = false;
    setPlayerStatus('Mirrors loaded');
    await resolveAndPlay();
  } catch(e) {
    setPlayerStatus('Mirror error: ' + e.message,'error');
  }
}

function populateSelectors(buttons) {
  const resSet = [...new Set(buttons.map(b => b.resolution).filter(Boolean))]
    .sort((a,b)=>parseInt(b)-parseInt(a));
  const audioSet = [...new Set(buttons.map(b => b.audio).filter(Boolean))];
  resSet.forEach(r=>{
    const opt = document.createElement('option');
    opt.value = r; opt.textContent = r+'p';
    els.resolutionSelect.appendChild(opt);
  });
  audioSet.forEach(a=>{
    const opt = document.createElement('option');
    opt.value = a; opt.textContent = a;
    els.audioSelect.appendChild(opt);
  });
}

async function resolveAndPlay() {
  if (!selectedAnime || !currentEpisode) return;
  setPlayerStatus('Resolving playlist ' + spinner());
  els.reloadPlaylistBtn.disabled = true;
  try {
    const slug = (selectedAnime.slug || selectedAnime.session || selectedAnime.id || '').trim();
    const qs = new URLSearchParams();
    if (els.resolutionSelect.value) qs.set('resolution', els.resolutionSelect.value);
    if (els.audioSelect.value) qs.set('audio', els.audioSelect.value);
    const playUrl = `/api/play/${encodeURIComponent(slug)}/${encodeURIComponent(currentEpisode.session)}?${qs.toString()}`;
    const r = await fetch(playUrl);
    const data = await r.json();
    if (!r.ok || !data.playlist) throw new Error(data.error || 'No playlist');
    lastPlaylistUrl = data.playlist;
    lastCookie = data.cookie || '';
    appliedResolution = els.resolutionSelect.value;
    appliedAudio = els.audioSelect.value;
    els.reloadPlaylistBtn.disabled = false;

    const proxied = buildProxiedPlaylist(lastPlaylistUrl, lastCookie);
    await playHls(proxied);
    setPlayerStatus(`Playing EP ${currentEpisode.episode} ${(appliedResolution||'AUTO')} ${(appliedAudio||'')}`.trim());
    await extractSubtitlesFromMaster(proxied);
  } catch (e) {
    setPlayerStatus('Playlist error: '+e.message,'error');
  }
}

function buildProxiedPlaylist(url,cookieVal){
  return '/api/hls?u='+encodeURIComponent(url)+(cookieVal?'&c='+encodeURIComponent(cookieVal):'');
}

async function playHls(url) {
  if (hlsInstance) { hlsInstance.destroy(); hlsInstance=null; }
  [...els.video.querySelectorAll('track')].forEach(t=>t.remove());
  if (window.Hls && Hls.isSupported()) {
    hlsInstance = new Hls({ enableWorker:true, lowLatencyMode:true });
    hlsInstance.loadSource(url);
    hlsInstance.attachMedia(els.video);
    hlsInstance.on(Hls.Events.ERROR,(evt,data)=>{
      if (data?.fatal) setPlayerStatus('Fatal HLS error','error');
    });
  } else if (els.video.canPlayType('application/vnd.apple.mpegurl')) {
    els.video.src = url;
  } else {
    setPlayerStatus('HLS unsupported','error');
  }
}

/* ========= SUBTITLES ========= */
async function extractSubtitlesFromMaster(masterUrl){
  subtitleTracks = [];
  activeSubtitleUri = '';
  els.subtitleSelect.innerHTML = '<option value="">Subtitles (None)</option>';
  try {
    const r = await fetch(masterUrl);
    if (!r.ok) return;
    const text = await r.text();
    parseSubs(text, masterUrl);
    subtitleTracks.forEach((t,i)=>{
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = t.label || t.lang || ('Track '+(i+1));
      els.subtitleSelect.appendChild(opt);
    });
  } catch {}
}

function parseSubs(text, baseUrl){
  const base = baseUrl.split('/').slice(0,-1).join('/');
  const lines = text.split(/\r?\n/);
  for (const l of lines){
    if (l.startsWith('#EXT-X-MEDIA') && /TYPE=SUBTITLES/.test(l)) {
      const u = l.match(/URI="([^"]+)"/);
      if (u) {
        let uri = u[1];
        if (!/^https?:/i.test(uri)) uri = base + '/' + uri.replace(/^\.\//,'');
        uri = buildProxiedPlaylist(uri, lastCookie);
        const lang = (l.match(/LANGUAGE="([^"]+)"/)||[])[1]||'';
        const name = (l.match(/NAME="([^"]+)"/)||[])[1]||lang||'Subtitle';
        subtitleTracks.push({ uri, lang, label:name });
      }
    }
  }
}

async function applySubtitle(index){
  [...els.video.querySelectorAll('track')].forEach(t=>t.remove());
  if (index==='' || index==null) return;
  const track = subtitleTracks[index];
  if (!track) return;
  try {
    const r = await fetch(track.uri);
    if (!r.ok) return;
    const text = await r.text();
    let finalVtt='';
    if (text.startsWith('WEBVTT')) finalVtt=text;
    else finalVtt='WEBVTT\n\n'+text;
    const blob = new Blob([finalVtt],{type:'text/vtt'});
    const url = URL.createObjectURL(blob);
    const tr = document.createElement('track');
    tr.kind='subtitles';
    tr.label=track.label;
    tr.srclang=track.lang||'und';
    tr.default=true;
    tr.src=url;
    els.video.appendChild(tr);
  } catch {}
}

/* ========= MIRRORS PANEL ========= */
function toggleMirrorPanel(open){
  if (open===true) els.mirrorPanel.classList.add('active');
  else if (open===false) els.mirrorPanel.classList.remove('active');
  else els.mirrorPanel.classList.toggle('active');
  if (els.mirrorPanel.classList.contains('active')) renderMirrors();
}
function renderMirrors(){
  els.mirrorList.innerHTML='';
  mirrorButtons.forEach(b=>{
    const div=document.createElement('div');
    div.className='mirror';
    div.innerHTML=`
      <div class="mirror-header">
        <span>${b.resolution || '?'}p</span>
        <span class="badge">${b.audio || '?'}</span>
      </div>
      <div style="font-size:.55rem;opacity:.6;word-break:break-all;">
        ${(b.src||'').replace(/^https?:\/\//,'')}
      </div>
      <button data-src="${b.src}">Play</button>
    `;
    div.querySelector('button').addEventListener('click', async ()=>{
      els.resolutionSelect.value = b.resolution || '';
      els.audioSelect.value = b.audio || '';
      toggleMirrorPanel(false);
      await resolveAndPlay();
    });
    els.mirrorList.appendChild(div);
  });
}

/* ========= EVENTS ========= */
els.searchBtn.addEventListener('click', doSearch);
els.searchInput.addEventListener('keydown', e=>{ if(e.key==='Enter') doSearch(); });
els.applyBtn.addEventListener('click', resolveAndPlay);
els.reloadPlaylistBtn.addEventListener('click', ()=> {
  if (lastPlaylistUrl) playHls(buildProxiedPlaylist(lastPlaylistUrl,lastCookie));
});
els.refreshMirrorsBtn.addEventListener('click', ()=> toggleMirrorPanel());
els.closeMirrorPanel.addEventListener('click', ()=> toggleMirrorPanel(false));
els.subtitleSelect.addEventListener('change', e=>{
  if (e.target.value==='') applySubtitle('');
  else applySubtitle(parseInt(e.target.value,10));
});
els.video.addEventListener('ended', ()=>{
  if (!autoplay || !currentEpisode) return;
  const idx = episodes.findIndex(e => e.session === currentEpisode.session);
  if (idx >=0 && idx < episodes.length-1) loadEpisode(episodes[idx+1]);
});
els.backBtn.addEventListener('click', ()=>{
  document.body.classList.remove('mode-player');
  selectedAnime=null;
  currentEpisode=null;
  clearPlayerState();
});
els.toggleAutoplayBtn.addEventListener('click', ()=>{
  autoplay = !autoplay;
  els.toggleAutoplayBtn.textContent='Autoplay: '+(autoplay?'On':'Off');
});

/* ========= INIT ========= */
setStatus('Ready.');

/* Optional: auto-focus search */
setTimeout(()=>{ els.searchInput.focus(); }, 50);
</script>
</body>
</html>
